Architektury Výpočetních Systémů (AVS 2021)
Projekt č. 2 (PMC)
Login: xpolok03

Úloha 1: Paralelizace původního řešení
===============================================================================

1) Kterou ze smyček (viz zadání) je vhodnější paralelizovat a co způsobuje 
   neefektivitu paralelizaci té druhé?
   Je vhodnější pararelizovat vnější smyčku ve funkci marchCubes, ma dostatečný počet iterací (gridSize^3) na to aby byla pararelizace výhodna a výpočet vně jedné iterace je dostatečně dlouhý na to aby nás nebrzdila režie.
   Naopak pokud bychom se rozhodli pararelizovat smyčku ve funkci evaluateFieldAt muselo by master vlákno čekat na výpočet vzdálenosti  vůči všem bodům příslušných vláken, zbortit výsledek a až pak se posunout na další pozici, navíc celý výpočet buildCube by probíhal sekvenčně.
   Další možností se jeví zpararelizovat obě smyčky, avšak nutná režie a přepinání kontextu zpomaluje výpočet.
   Zrychlení výpočtu bylo dále dosaženo vektorizaci smyčky v evaluateFieldAt.

2) Jaké plánování (rozdělení práce mezi vlákna) jste zvolili a proč? 
   Jaký vliv má velikost "chunk" při dynamickém plánování (8, 16, 32, 64)?
   Jelikož výpočet mezi iteracemi se nijak neliší je zcela přirozené použít statické plánování. Provedené experimenty toto zjištění potvrdily.
   Iterace na sebe nejsou nijak závislé tedy ideálně chceme rozdistribuovat všechen výpočet mezi vlákna ekvivaletně a vyhnout se jakékoliv režii.
   Uvažme celkový objem práce jako W a počet vláken jako N. Idealní volbou by byl chunk o velikosti W/N.
   V tomto případě se dostaneme s dynamickým plánováním na podobnou rychlost jako ze statickým.



3) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?
   Naivním řešením se jeví sekce critical případně atomic, ty však vedou k zbytečnému zámku a čekání mezi vlákny k přístupu k bufferu.
   Předělal jsem tedy 1D buffer na 2D buffer, kde maximální počet vláken úrčuje velikost první dimenze. Příslušné buffery jsou na konci výpočtu zřetězeny.


Úloha 2: Paralelní průchod stromem
===============================================================================

1) Stručně popište použití OpenMP tasků ve vašem řešení.

2) Jakým způsobem jste realizovali sesbírání celkového počtu trojúhelníků?

3) Jaký vliv má na vaše řešení tzv. "cut-off"? Je vhodné vytvářet nový 
   task pro každou krychli na nejnižší úrovni?

4) Jakým způsobem zajišťujete ukládání trojúhelníků z několika vláken současně?

Úloha 3: Grafy škálování všech řešení
===============================================================================

1) Stručně zhodnoťte efektivitu vytvořených řešení (na základě grafů škálování).

2) V jakém případě (v závislosti na počtu bodů ve vstupním souboru a velikosti 
   mřížky) bude vaše řešení 1. úlohy neefektivní? (pokud takový případ existuje)

3) Je (nebo není) stromový algoritmus efektivnější z pohledu slabého škálování 
   vzhledem ke vstupu?

Úloha 4: Analýza využití jader pomocí VTune
================================================================================

1) Jaké bylo průměrné využití jader pro všechny tři implementace s omezením na 
   18 vláken? Na kolik procent byly využity?
   
   ref:
   loop:
   tree:

2) Jaké bylo průměrné využití jader pro všechny tři implementace s využitím 
   všech jader? Na kolik procent se podařilo využít obě CPU?
   
   ref:
   loop:
   tree:

3) Jaké jsou závěry z těchto měření?

